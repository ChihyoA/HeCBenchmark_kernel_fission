main.cu:55:18: warning: ISO C++11 does not allow conversion from string literal to 'char *' [-Wwritable-strings]
    char *path = "../../data/dwt2d/";
                 ^
main.cu:55:18: warning: ISO C++11 does not allow conversion from string literal to 'char *' [-Wwritable-strings]
    char *path = "../../data/dwt2d/";
                 ^
<immediate: mlir>
module attributes {llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", llvm.target_triple = "nvptx64-nvidia-cuda"}  {
  llvm.mlir.global internal constant @str15("help\00")
  llvm.mlir.global internal constant @str14("write-visual\00")
  llvm.mlir.global internal constant @str13("53\00")
  llvm.mlir.global internal constant @str12("97\00")
  llvm.mlir.global internal constant @str11("reverse\00")
  llvm.mlir.global internal constant @str10("forward\00")
  llvm.mlir.global internal constant @str9("device\00")
  llvm.mlir.global internal constant @str8("level\00")
  llvm.mlir.global internal constant @str7("depth\00")
  llvm.mlir.global internal constant @str6("components\00")
  llvm.mlir.global internal constant @str5("dimension\00")
  llvm.mlir.global internal constant @str4("dwt [otpions] src_img.rgb <out_img.dwt>\0A  -d, --dimension\09\09dimensions of src img, e.g. 1920x1080\0A  -c, --components\09\09number of color components, default 3\0A  -b, --depth\09\09\09bit depth, default 8\0A  -l, --level\09\09\09DWT level, default 3\0A  -D, --device\09\09\09cuda device\0A  -f, --forward\09\09\09forward transform\0A  -r, --reverse\09\09\09reverse transform\0A  -9, --97\09\09\099/7 transform\0A  -5, --53\09\09\095/3 transform\0A  -w  --write-visual\09\09write output in visual (tiled) fashion instead of the linear\0A\00")
  llvm.func @close(i32) -> i32
  llvm.mlir.global internal constant @str3("precteno %d, inputsize %d\0A\00")
  llvm.func @read(i32, !llvm.ptr<i8>, i64) -> i64
  llvm.func @error(i32, i32, !llvm.ptr<i8>, ...)
  llvm.mlir.global internal constant @str2("cannot access %s\00")
  llvm.func @__errno_location() -> !llvm.ptr<i32>
  llvm.func @open(!llvm.ptr<i8>, i32, ...) -> i32
  llvm.func @printf(!llvm.ptr<i8>, ...) -> i32
  llvm.mlir.global internal constant @str1("Loading ipnput: %s\0A\00")
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.mlir.global internal constant @str0("../../data/dwt2d/\00")
  func private @cudaFuncGetAttributes(%arg0: !llvm.ptr<struct<(i64, i64, i64, i32, i32, i32, i32, i32, i32, i32)>>, %arg1: !llvm.ptr<i8>) -> i32 attributes {llvm.linkage = #llvm.linkage<weak>} {
    %c1_i64 = arith.constant 1 : i64
    %0 = llvm.alloca %c1_i64 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %c1_i64_0 = arith.constant 1 : i64
    %1 = llvm.alloca %c1_i64_0 x !llvm.ptr<struct<(i64, i64, i64, i32, i32, i32, i32, i32, i32, i32)>> : (i64) -> !llvm.ptr<ptr<struct<(i64, i64, i64, i32, i32, i32, i32, i32, i32, i32)>>>
    llvm.store %arg0, %1 : !llvm.ptr<ptr<struct<(i64, i64, i64, i32, i32, i32, i32, i32, i32, i32)>>>
    llvm.store %arg1, %0 : !llvm.ptr<ptr<i8>>
    %true = arith.constant true
    %2 = memref.alloca() : memref<i1>
    %3 = memref.alloca() : memref<i1>
    memref.store %true, %3[] : memref<i1>
    memref.store %true, %2[] : memref<i1>
    %4 = memref.alloca() : memref<i32>
    %5 = llvm.mlir.undef : i32
    memref.store %5, %4[] : memref<i32>
    %6 = memref.load %2[] : memref<i1>
    scf.if %6 {
      scf.execute_region {
        %8 = memref.load %2[] : memref<i1>
        scf.if %8 {
          scf.execute_region {
            %c999_i32 = arith.constant 999 : i32
            memref.store %c999_i32, %4[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %2[] : memref<i1>
            memref.store %false, %3[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %7 = memref.load %4[] : memref<i32>
    return %7 : i32
  }
  func private @cudaDeviceGetAttribute(%arg0: memref<?xi32>, %arg1: i32, %arg2: i32) -> i32 attributes {llvm.linkage = #llvm.linkage<weak>} {
    %0 = memref.alloca() : memref<1xi32>
    %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
    %c0 = arith.constant 0 : index
    %2 = llvm.mlir.undef : i32
    memref.store %2, %1[%c0] : memref<?xi32>
    %3 = memref.alloca() : memref<1xi32>
    %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
    %c0_0 = arith.constant 0 : index
    %5 = llvm.mlir.undef : i32
    memref.store %5, %4[%c0_0] : memref<?xi32>
    %6 = memref.alloca() : memref<1xmemref<?xi32>>
    %7 = memref.cast %6 : memref<1xmemref<?xi32>> to memref<?xmemref<?xi32>>
    %c0_1 = arith.constant 0 : index
    memref.store %arg0, %7[%c0_1] : memref<?xmemref<?xi32>>
    %c0_2 = arith.constant 0 : index
    memref.store %arg1, %4[%c0_2] : memref<?xi32>
    %c0_3 = arith.constant 0 : index
    memref.store %arg2, %1[%c0_3] : memref<?xi32>
    %true = arith.constant true
    %8 = memref.alloca() : memref<i1>
    %9 = memref.alloca() : memref<i1>
    memref.store %true, %9[] : memref<i1>
    memref.store %true, %8[] : memref<i1>
    %10 = memref.alloca() : memref<i32>
    %11 = llvm.mlir.undef : i32
    memref.store %11, %10[] : memref<i32>
    %12 = memref.load %8[] : memref<i1>
    scf.if %12 {
      scf.execute_region {
        %14 = memref.load %8[] : memref<i1>
        scf.if %14 {
          scf.execute_region {
            %c999_i32 = arith.constant 999 : i32
            memref.store %c999_i32, %10[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %8[] : memref<i1>
            memref.store %false, %9[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %13 = memref.load %10[] : memref<i32>
    return %13 : i32
  }
  func private @cudaOccupancyMaxActiveBlocksPerMultiprocessor(%arg0: memref<?xi32>, %arg1: !llvm.ptr<i8>, %arg2: i32, %arg3: i64) -> i32 attributes {llvm.linkage = #llvm.linkage<weak>} {
    %0 = memref.alloca() : memref<1xi64>
    %1 = memref.cast %0 : memref<1xi64> to memref<?xi64>
    %c0 = arith.constant 0 : index
    %2 = llvm.mlir.undef : i64
    memref.store %2, %1[%c0] : memref<?xi64>
    %3 = memref.alloca() : memref<1xi32>
    %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
    %c0_0 = arith.constant 0 : index
    %5 = llvm.mlir.undef : i32
    memref.store %5, %4[%c0_0] : memref<?xi32>
    %c1_i64 = arith.constant 1 : i64
    %6 = llvm.alloca %c1_i64 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %7 = memref.alloca() : memref<1xmemref<?xi32>>
    %8 = memref.cast %7 : memref<1xmemref<?xi32>> to memref<?xmemref<?xi32>>
    %c0_1 = arith.constant 0 : index
    memref.store %arg0, %8[%c0_1] : memref<?xmemref<?xi32>>
    llvm.store %arg1, %6 : !llvm.ptr<ptr<i8>>
    %c0_2 = arith.constant 0 : index
    memref.store %arg2, %4[%c0_2] : memref<?xi32>
    %c0_3 = arith.constant 0 : index
    memref.store %arg3, %1[%c0_3] : memref<?xi64>
    %true = arith.constant true
    %9 = memref.alloca() : memref<i1>
    %10 = memref.alloca() : memref<i1>
    memref.store %true, %10[] : memref<i1>
    memref.store %true, %9[] : memref<i1>
    %11 = memref.alloca() : memref<i32>
    %12 = llvm.mlir.undef : i32
    memref.store %12, %11[] : memref<i32>
    %13 = memref.load %9[] : memref<i1>
    scf.if %13 {
      scf.execute_region {
        %15 = memref.load %9[] : memref<i1>
        scf.if %15 {
          scf.execute_region {
            %c999_i32 = arith.constant 999 : i32
            memref.store %c999_i32, %11[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %9[] : memref<i1>
            memref.store %false, %10[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %14 = memref.load %11[] : memref<i32>
    return %14 : i32
  }
  func private @cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(%arg0: memref<?xi32>, %arg1: !llvm.ptr<i8>, %arg2: i32, %arg3: i64, %arg4: i32) -> i32 attributes {llvm.linkage = #llvm.linkage<weak>} {
    %0 = memref.alloca() : memref<1xi32>
    %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
    %c0 = arith.constant 0 : index
    %2 = llvm.mlir.undef : i32
    memref.store %2, %1[%c0] : memref<?xi32>
    %3 = memref.alloca() : memref<1xi64>
    %4 = memref.cast %3 : memref<1xi64> to memref<?xi64>
    %c0_0 = arith.constant 0 : index
    %5 = llvm.mlir.undef : i64
    memref.store %5, %4[%c0_0] : memref<?xi64>
    %6 = memref.alloca() : memref<1xi32>
    %7 = memref.cast %6 : memref<1xi32> to memref<?xi32>
    %c0_1 = arith.constant 0 : index
    %8 = llvm.mlir.undef : i32
    memref.store %8, %7[%c0_1] : memref<?xi32>
    %c1_i64 = arith.constant 1 : i64
    %9 = llvm.alloca %c1_i64 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %10 = memref.alloca() : memref<1xmemref<?xi32>>
    %11 = memref.cast %10 : memref<1xmemref<?xi32>> to memref<?xmemref<?xi32>>
    %c0_2 = arith.constant 0 : index
    memref.store %arg0, %11[%c0_2] : memref<?xmemref<?xi32>>
    llvm.store %arg1, %9 : !llvm.ptr<ptr<i8>>
    %c0_3 = arith.constant 0 : index
    memref.store %arg2, %7[%c0_3] : memref<?xi32>
    %c0_4 = arith.constant 0 : index
    memref.store %arg3, %4[%c0_4] : memref<?xi64>
    %c0_5 = arith.constant 0 : index
    memref.store %arg4, %1[%c0_5] : memref<?xi32>
    %true = arith.constant true
    %12 = memref.alloca() : memref<i1>
    %13 = memref.alloca() : memref<i1>
    memref.store %true, %13[] : memref<i1>
    memref.store %true, %12[] : memref<i1>
    %14 = memref.alloca() : memref<i32>
    %15 = llvm.mlir.undef : i32
    memref.store %15, %14[] : memref<i32>
    %16 = memref.load %12[] : memref<i1>
    scf.if %16 {
      scf.execute_region {
        %18 = memref.load %12[] : memref<i1>
        scf.if %18 {
          scf.execute_region {
            %c999_i32 = arith.constant 999 : i32
            memref.store %c999_i32, %14[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %12[] : memref<i1>
            memref.store %false, %13[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %17 = memref.load %14[] : memref<i32>
    return %17 : i32
  }
  func @_Z6getImgPcPhi(%arg0: !llvm.ptr<i8>, %arg1: !llvm.ptr<i8>, %arg2: i32) -> i32 attributes {llvm.linkage = #llvm.linkage<external>} {
    %0 = memref.alloca() : memref<1xi32>
    %1 = memref.cast %0 : memref<1xi32> to memref<?xi32>
    %c0 = arith.constant 0 : index
    %2 = llvm.mlir.undef : i32
    memref.store %2, %1[%c0] : memref<?xi32>
    %3 = memref.alloca() : memref<1xi32>
    %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
    %c0_0 = arith.constant 0 : index
    %5 = llvm.mlir.undef : i32
    memref.store %5, %4[%c0_0] : memref<?xi32>
    %c0_1 = arith.constant 0 : index
    %c1_i64 = arith.constant 1 : i64
    %6 = llvm.alloca %c1_i64 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %c1_i64_2 = arith.constant 1 : i64
    %7 = llvm.alloca %c1_i64_2 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %8 = memref.alloca() : memref<1xi32>
    %9 = memref.cast %8 : memref<1xi32> to memref<?xi32>
    %c0_3 = arith.constant 0 : index
    %10 = llvm.mlir.undef : i32
    memref.store %10, %9[%c0_3] : memref<?xi32>
    %c1_i64_4 = arith.constant 1 : i64
    %11 = llvm.alloca %c1_i64_4 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    %c1_i64_5 = arith.constant 1 : i64
    %12 = llvm.alloca %c1_i64_5 x !llvm.ptr<i8> : (i64) -> !llvm.ptr<ptr<i8>>
    llvm.store %arg0, %12 : !llvm.ptr<ptr<i8>>
    llvm.store %arg1, %11 : !llvm.ptr<ptr<i8>>
    %c0_6 = arith.constant 0 : index
    memref.store %arg2, %9[%c0_6] : memref<?xi32>
    %true = arith.constant true
    %13 = memref.alloca() : memref<i1>
    %14 = memref.alloca() : memref<i1>
    memref.store %true, %14[] : memref<i1>
    memref.store %true, %13[] : memref<i1>
    %15 = memref.alloca() : memref<i32>
    %16 = llvm.mlir.undef : i32
    memref.store %16, %15[] : memref<i32>
    %17 = memref.load %13[] : memref<i1>
    scf.if %17 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %29 = llvm.mlir.addressof @str0 : !llvm.ptr<array<18 x i8>>
            %c0_i32 = arith.constant 0 : i32
            %c0_i32_7 = arith.constant 0 : i32
            %30 = llvm.getelementptr %29[%c0_i32, %c0_i32_7] : (!llvm.ptr<array<18 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %30, %7 : !llvm.ptr<ptr<i8>>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %18 = memref.load %13[] : memref<i1>
    scf.if %18 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %29 = llvm.mlir.null : !llvm.ptr<i8>
            llvm.store %29, %6 : !llvm.ptr<ptr<i8>>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %19 = memref.load %13[] : memref<i1>
    scf.if %19 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %29 = llvm.load %12 : !llvm.ptr<ptr<i8>>
            %30 = call @strlen(%29) : (!llvm.ptr<i8>) -> i64
            %31 = llvm.load %7 : !llvm.ptr<ptr<i8>>
            %32 = call @strlen(%31) : (!llvm.ptr<i8>) -> i64
            %33 = arith.addi %30, %32 : i64
            %c1_i32 = arith.constant 1 : i32
            %c1_i64_7 = arith.constant 1 : i64
            %34 = arith.addi %33, %c1_i64_7 : i64
            %35 = llvm.call @malloc(%34) : (i64) -> !llvm.ptr<i8>
            %36 = llvm.bitcast %35 : !llvm.ptr<i8> to !llvm.ptr<i8>
            llvm.store %36, %6 : !llvm.ptr<ptr<i8>>
            %37 = llvm.load %6 : !llvm.ptr<ptr<i8>>
            %38 = llvm.mlir.null : !llvm.ptr<i8>
            %39 = llvm.icmp "ne" %37, %38 : !llvm.ptr<i8>
            %40 = arith.extui %39 : i1 to i8
            %c0_i8 = arith.constant 0 : i8
            %41 = arith.cmpi ne, %40, %c0_i8 : i8
            scf.if %41 {
              %42 = memref.load %13[] : memref<i1>
              scf.if %42 {
                scf.execute_region {
                  %46 = llvm.load %6 : !llvm.ptr<ptr<i8>>
                  %c0_i32 = arith.constant 0 : i32
                  %47 = arith.index_cast %c0_1 : index to i64
                  %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<i8>, i64) -> !llvm.ptr<i8>
                  %c0_i8_8 = arith.constant 0 : i8
                  llvm.store %c0_i8_8, %48 : !llvm.ptr<i8>
                  scf.yield
                }
              }
              %43 = memref.load %13[] : memref<i1>
              scf.if %43 {
                scf.execute_region {
                  %46 = llvm.load %6 : !llvm.ptr<ptr<i8>>
                  %47 = llvm.load %7 : !llvm.ptr<ptr<i8>>
                  %48 = call @strcat(%46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
                  scf.yield
                }
              }
              %44 = memref.load %13[] : memref<i1>
              scf.if %44 {
                scf.execute_region {
                  %46 = llvm.load %6 : !llvm.ptr<ptr<i8>>
                  %47 = llvm.load %12 : !llvm.ptr<ptr<i8>>
                  %48 = call @strcat(%46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
                  scf.yield
                }
              }
              %45 = memref.load %13[] : memref<i1>
              scf.if %45 {
                scf.execute_region {
                  %46 = llvm.load %6 : !llvm.ptr<ptr<i8>>
                  llvm.store %46, %12 : !llvm.ptr<ptr<i8>>
                  scf.yield
                }
              }
            }
            scf.yield
          }
        }
        scf.yield
      }
    }
    %20 = memref.load %13[] : memref<i1>
    scf.if %20 {
      scf.execute_region {
        %28 = llvm.mlir.addressof @str1 : !llvm.ptr<array<20 x i8>>
        %c0_i32 = arith.constant 0 : i32
        %c0_i32_7 = arith.constant 0 : i32
        %29 = llvm.getelementptr %28[%c0_i32, %c0_i32_7] : (!llvm.ptr<array<20 x i8>>, i32, i32) -> !llvm.ptr<i8>
        %30 = llvm.load %12 : !llvm.ptr<ptr<i8>>
        %31 = llvm.call @printf(%29, %30) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
        scf.yield
      }
    }
    %21 = memref.load %13[] : memref<i1>
    scf.if %21 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %29 = llvm.load %12 : !llvm.ptr<ptr<i8>>
            %c0_i32 = arith.constant 0 : i32
            %c420_i32 = arith.constant 420 : i32
            %30 = llvm.call @open(%29, %c0_i32, %c420_i32) : (!llvm.ptr<i8>, i32, i32) -> i32
            %c0_7 = arith.constant 0 : index
            memref.store %30, %4[%c0_7] : memref<?xi32>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %22 = memref.load %13[] : memref<i1>
    scf.if %22 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %c0_7 = arith.constant 0 : index
            %29 = memref.load %4[%c0_7] : memref<?xi32>
            %c1_i32 = arith.constant 1 : i32
            %c-1_i32 = arith.constant -1 : i32
            %30 = arith.cmpi eq, %29, %c-1_i32 : i32
            %31 = arith.extui %30 : i1 to i8
            %c0_i8 = arith.constant 0 : i8
            %32 = arith.cmpi ne, %31, %c0_i8 : i8
            scf.if %32 {
              %33 = memref.load %13[] : memref<i1>
              scf.if %33 {
                scf.execute_region {
                  %c0_i32 = arith.constant 0 : i32
                  %35 = llvm.call @__errno_location() : () -> !llvm.ptr<i32>
                  %36 = llvm.load %35 : !llvm.ptr<i32>
                  %37 = llvm.mlir.addressof @str2 : !llvm.ptr<array<17 x i8>>
                  %c0_i32_8 = arith.constant 0 : i32
                  %c0_i32_9 = arith.constant 0 : i32
                  %38 = llvm.getelementptr %37[%c0_i32_8, %c0_i32_9] : (!llvm.ptr<array<17 x i8>>, i32, i32) -> !llvm.ptr<i8>
                  %39 = llvm.load %12 : !llvm.ptr<ptr<i8>>
                  llvm.call @error(%c0_i32, %36, %38, %39) : (i32, i32, !llvm.ptr<i8>, !llvm.ptr<i8>) -> ()
                  scf.yield
                }
              }
              %34 = memref.load %13[] : memref<i1>
              scf.if %34 {
                scf.execute_region {
                  %35 = memref.load %13[] : memref<i1>
                  scf.if %35 {
                    scf.execute_region {
                      %c1_i32_8 = arith.constant 1 : i32
                      %c-1_i32_9 = arith.constant -1 : i32
                      memref.store %c-1_i32_9, %15[] : memref<i32>
                      %false = arith.constant false
                      memref.store %false, %13[] : memref<i1>
                      memref.store %false, %14[] : memref<i1>
                      scf.yield
                    }
                  }
                  scf.yield
                }
              }
            }
            scf.yield
          }
        }
        scf.yield
      }
    }
    %23 = memref.load %13[] : memref<i1>
    scf.if %23 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %c0_7 = arith.constant 0 : index
            %29 = memref.load %4[%c0_7] : memref<?xi32>
            %30 = llvm.load %11 : !llvm.ptr<ptr<i8>>
            %31 = llvm.bitcast %30 : !llvm.ptr<i8> to !llvm.ptr<i8>
            %c0_8 = arith.constant 0 : index
            %32 = memref.load %9[%c0_8] : memref<?xi32>
            %33 = arith.extsi %32 : i32 to i64
            %34 = llvm.call @read(%29, %31, %33) : (i32, !llvm.ptr<i8>, i64) -> i64
            %35 = arith.trunci %34 : i64 to i32
            %c0_9 = arith.constant 0 : index
            memref.store %35, %1[%c0_9] : memref<?xi32>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %24 = memref.load %13[] : memref<i1>
    scf.if %24 {
      scf.execute_region {
        %28 = llvm.mlir.addressof @str3 : !llvm.ptr<array<27 x i8>>
        %c0_i32 = arith.constant 0 : i32
        %c0_i32_7 = arith.constant 0 : i32
        %29 = llvm.getelementptr %28[%c0_i32, %c0_i32_7] : (!llvm.ptr<array<27 x i8>>, i32, i32) -> !llvm.ptr<i8>
        %c0_8 = arith.constant 0 : index
        %30 = memref.load %1[%c0_8] : memref<?xi32>
        %c0_9 = arith.constant 0 : index
        %31 = memref.load %9[%c0_9] : memref<?xi32>
        %32 = llvm.call @printf(%29, %30, %31) : (!llvm.ptr<i8>, i32, i32) -> i32
        scf.yield
      }
    }
    %25 = memref.load %13[] : memref<i1>
    scf.if %25 {
      scf.execute_region {
        %c0_7 = arith.constant 0 : index
        %28 = memref.load %4[%c0_7] : memref<?xi32>
        %29 = llvm.call @close(%28) : (i32) -> i32
        scf.yield
      }
    }
    %26 = memref.load %13[] : memref<i1>
    scf.if %26 {
      scf.execute_region {
        %28 = memref.load %13[] : memref<i1>
        scf.if %28 {
          scf.execute_region {
            %c0_i32 = arith.constant 0 : i32
            memref.store %c0_i32, %15[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %13[] : memref<i1>
            memref.store %false, %14[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %27 = memref.load %15[] : memref<i32>
    return %27 : i32
  }
  func private @strlen(!llvm.ptr<i8>) -> i64
  func private @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {llvm.linkage = #llvm.linkage<external>}
  func @_Z5usagev() attributes {llvm.linkage = #llvm.linkage<external>} {
    %true = arith.constant true
    %0 = memref.alloca() : memref<i1>
    %1 = memref.alloca() : memref<i1>
    memref.store %true, %1[] : memref<i1>
    memref.store %true, %0[] : memref<i1>
    %2 = memref.load %0[] : memref<i1>
    scf.if %2 {
      scf.execute_region {
        %3 = llvm.mlir.addressof @str4 : !llvm.ptr<array<468 x i8>>
        %c0_i32 = arith.constant 0 : i32
        %c0_i32_0 = arith.constant 0 : i32
        %4 = llvm.getelementptr %3[%c0_i32, %c0_i32_0] : (!llvm.ptr<array<468 x i8>>, i32, i32) -> !llvm.ptr<i8>
        %5 = llvm.call @printf(%4) : (!llvm.ptr<i8>) -> i32
        scf.yield
      }
    }
    return
  }
  func @main(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>) -> i32 attributes {llvm.linkage = #llvm.linkage<external>} {
    %c1_i64 = arith.constant 1 : i64
    %0 = llvm.alloca %c1_i64 x !llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>> : (i64) -> !llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>
    %c1_i64_0 = arith.constant 1 : i64
    %1 = llvm.alloca %c1_i64_0 x i8 : (i64) -> !llvm.ptr<i8>
    %2 = llvm.mlir.undef : i8
    llvm.store %2, %1 : !llvm.ptr<i8>
    %3 = memref.alloca() : memref<1xi32>
    %4 = memref.cast %3 : memref<1xi32> to memref<?xi32>
    %c0 = arith.constant 0 : index
    %5 = llvm.mlir.undef : i32
    memref.store %5, %4[%c0] : memref<?xi32>
    %c1_i64_1 = arith.constant 1 : i64
    %6 = llvm.alloca %c1_i64_1 x !llvm.ptr<ptr<i8>> : (i64) -> !llvm.ptr<ptr<ptr<i8>>>
    %7 = memref.alloca() : memref<1xi32>
    %8 = memref.cast %7 : memref<1xi32> to memref<?xi32>
    %c0_2 = arith.constant 0 : index
    %9 = llvm.mlir.undef : i32
    memref.store %9, %8[%c0_2] : memref<?xi32>
    %c0_3 = arith.constant 0 : index
    memref.store %arg0, %8[%c0_3] : memref<?xi32>
    llvm.store %arg1, %6 : !llvm.ptr<ptr<ptr<i8>>>
    %true = arith.constant true
    %10 = memref.alloca() : memref<i1>
    %11 = memref.alloca() : memref<i1>
    memref.store %true, %11[] : memref<i1>
    memref.store %true, %10[] : memref<i1>
    %12 = memref.alloca() : memref<i32>
    %13 = llvm.mlir.undef : i32
    memref.store %13, %12[] : memref<i32>
    %14 = memref.load %10[] : memref<i1>
    scf.if %14 {
      scf.execute_region {
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          scf.execute_region {
            %c0_i32 = arith.constant 0 : i32
            %c0_4 = arith.constant 0 : index
            memref.store %c0_i32, %4[%c0_4] : memref<?xi32>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %15 = memref.load %10[] : memref<i1>
    scf.if %15 {
      scf.execute_region {
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          scf.execute_region {
            scf.yield
          }
        }
        scf.yield
      }
    }
    %16 = memref.load %10[] : memref<i1>
    scf.if %16 {
      scf.execute_region {
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          scf.execute_region {
            %c0_i32 = arith.constant 0 : i32
            %c0_i32_4 = arith.constant 0 : i32
            %20 = llvm.getelementptr %0[%c0_i32, %c0_i32_4] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_5 = arith.constant 0 : i32
            %c0_i32_6 = arith.constant 0 : i32
            %21 = llvm.getelementptr %20[%c0_i32_5, %c0_i32_6] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %22 = llvm.mlir.addressof @str5 : !llvm.ptr<array<10 x i8>>
            %c0_i32_7 = arith.constant 0 : i32
            %c0_i32_8 = arith.constant 0 : i32
            %23 = llvm.getelementptr %22[%c0_i32_7, %c0_i32_8] : (!llvm.ptr<array<10 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %23, %21 : !llvm.ptr<ptr<i8>>
            %c0_i32_9 = arith.constant 0 : i32
            %c1_i32 = arith.constant 1 : i32
            %24 = llvm.getelementptr %20[%c0_i32_9, %c1_i32] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c1_i32_10 = arith.constant 1 : i32
            llvm.store %c1_i32_10, %24 : !llvm.ptr<i32>
            %c0_i32_11 = arith.constant 0 : i32
            %c2_i32 = arith.constant 2 : i32
            %25 = llvm.getelementptr %20[%c0_i32_11, %c2_i32] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %26 = llvm.mlir.null : !llvm.ptr<i8>
            %27 = "polygeist.pointer2memref"(%26) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %27, %25 : !llvm.ptr<memref<?xi32>>
            %c0_i32_12 = arith.constant 0 : i32
            %c3_i32 = arith.constant 3 : i32
            %28 = llvm.getelementptr %20[%c0_i32_12, %c3_i32] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c100_i8 = arith.constant 100 : i8
            %c100_i32 = arith.constant 100 : i32
            llvm.store %c100_i32, %28 : !llvm.ptr<i32>
            %c0_i32_13 = arith.constant 0 : i32
            %c1_i32_14 = arith.constant 1 : i32
            %29 = llvm.getelementptr %0[%c0_i32_13, %c1_i32_14] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_15 = arith.constant 0 : i32
            %c0_i32_16 = arith.constant 0 : i32
            %30 = llvm.getelementptr %29[%c0_i32_15, %c0_i32_16] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %31 = llvm.mlir.addressof @str6 : !llvm.ptr<array<11 x i8>>
            %c0_i32_17 = arith.constant 0 : i32
            %c0_i32_18 = arith.constant 0 : i32
            %32 = llvm.getelementptr %31[%c0_i32_17, %c0_i32_18] : (!llvm.ptr<array<11 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %32, %30 : !llvm.ptr<ptr<i8>>
            %c0_i32_19 = arith.constant 0 : i32
            %c1_i32_20 = arith.constant 1 : i32
            %33 = llvm.getelementptr %29[%c0_i32_19, %c1_i32_20] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c1_i32_21 = arith.constant 1 : i32
            llvm.store %c1_i32_21, %33 : !llvm.ptr<i32>
            %c0_i32_22 = arith.constant 0 : i32
            %c2_i32_23 = arith.constant 2 : i32
            %34 = llvm.getelementptr %29[%c0_i32_22, %c2_i32_23] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %35 = llvm.mlir.null : !llvm.ptr<i8>
            %36 = "polygeist.pointer2memref"(%35) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %36, %34 : !llvm.ptr<memref<?xi32>>
            %c0_i32_24 = arith.constant 0 : i32
            %c3_i32_25 = arith.constant 3 : i32
            %37 = llvm.getelementptr %29[%c0_i32_24, %c3_i32_25] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c99_i8 = arith.constant 99 : i8
            %c99_i32 = arith.constant 99 : i32
            llvm.store %c99_i32, %37 : !llvm.ptr<i32>
            %c0_i32_26 = arith.constant 0 : i32
            %c2_i32_27 = arith.constant 2 : i32
            %38 = llvm.getelementptr %0[%c0_i32_26, %c2_i32_27] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_28 = arith.constant 0 : i32
            %c0_i32_29 = arith.constant 0 : i32
            %39 = llvm.getelementptr %38[%c0_i32_28, %c0_i32_29] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %40 = llvm.mlir.addressof @str7 : !llvm.ptr<array<6 x i8>>
            %c0_i32_30 = arith.constant 0 : i32
            %c0_i32_31 = arith.constant 0 : i32
            %41 = llvm.getelementptr %40[%c0_i32_30, %c0_i32_31] : (!llvm.ptr<array<6 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %41, %39 : !llvm.ptr<ptr<i8>>
            %c0_i32_32 = arith.constant 0 : i32
            %c1_i32_33 = arith.constant 1 : i32
            %42 = llvm.getelementptr %38[%c0_i32_32, %c1_i32_33] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c1_i32_34 = arith.constant 1 : i32
            llvm.store %c1_i32_34, %42 : !llvm.ptr<i32>
            %c0_i32_35 = arith.constant 0 : i32
            %c2_i32_36 = arith.constant 2 : i32
            %43 = llvm.getelementptr %38[%c0_i32_35, %c2_i32_36] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %44 = llvm.mlir.null : !llvm.ptr<i8>
            %45 = "polygeist.pointer2memref"(%44) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %45, %43 : !llvm.ptr<memref<?xi32>>
            %c0_i32_37 = arith.constant 0 : i32
            %c3_i32_38 = arith.constant 3 : i32
            %46 = llvm.getelementptr %38[%c0_i32_37, %c3_i32_38] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c98_i8 = arith.constant 98 : i8
            %c98_i32 = arith.constant 98 : i32
            llvm.store %c98_i32, %46 : !llvm.ptr<i32>
            %c0_i32_39 = arith.constant 0 : i32
            %c3_i32_40 = arith.constant 3 : i32
            %47 = llvm.getelementptr %0[%c0_i32_39, %c3_i32_40] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_41 = arith.constant 0 : i32
            %c0_i32_42 = arith.constant 0 : i32
            %48 = llvm.getelementptr %47[%c0_i32_41, %c0_i32_42] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %49 = llvm.mlir.addressof @str8 : !llvm.ptr<array<6 x i8>>
            %c0_i32_43 = arith.constant 0 : i32
            %c0_i32_44 = arith.constant 0 : i32
            %50 = llvm.getelementptr %49[%c0_i32_43, %c0_i32_44] : (!llvm.ptr<array<6 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %50, %48 : !llvm.ptr<ptr<i8>>
            %c0_i32_45 = arith.constant 0 : i32
            %c1_i32_46 = arith.constant 1 : i32
            %51 = llvm.getelementptr %47[%c0_i32_45, %c1_i32_46] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c1_i32_47 = arith.constant 1 : i32
            llvm.store %c1_i32_47, %51 : !llvm.ptr<i32>
            %c0_i32_48 = arith.constant 0 : i32
            %c2_i32_49 = arith.constant 2 : i32
            %52 = llvm.getelementptr %47[%c0_i32_48, %c2_i32_49] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %53 = llvm.mlir.null : !llvm.ptr<i8>
            %54 = "polygeist.pointer2memref"(%53) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %54, %52 : !llvm.ptr<memref<?xi32>>
            %c0_i32_50 = arith.constant 0 : i32
            %c3_i32_51 = arith.constant 3 : i32
            %55 = llvm.getelementptr %47[%c0_i32_50, %c3_i32_51] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c108_i8 = arith.constant 108 : i8
            %c108_i32 = arith.constant 108 : i32
            llvm.store %c108_i32, %55 : !llvm.ptr<i32>
            %c0_i32_52 = arith.constant 0 : i32
            %c4_i32 = arith.constant 4 : i32
            %56 = llvm.getelementptr %0[%c0_i32_52, %c4_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_53 = arith.constant 0 : i32
            %c0_i32_54 = arith.constant 0 : i32
            %57 = llvm.getelementptr %56[%c0_i32_53, %c0_i32_54] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %58 = llvm.mlir.addressof @str9 : !llvm.ptr<array<7 x i8>>
            %c0_i32_55 = arith.constant 0 : i32
            %c0_i32_56 = arith.constant 0 : i32
            %59 = llvm.getelementptr %58[%c0_i32_55, %c0_i32_56] : (!llvm.ptr<array<7 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %59, %57 : !llvm.ptr<ptr<i8>>
            %c0_i32_57 = arith.constant 0 : i32
            %c1_i32_58 = arith.constant 1 : i32
            %60 = llvm.getelementptr %56[%c0_i32_57, %c1_i32_58] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c1_i32_59 = arith.constant 1 : i32
            llvm.store %c1_i32_59, %60 : !llvm.ptr<i32>
            %c0_i32_60 = arith.constant 0 : i32
            %c2_i32_61 = arith.constant 2 : i32
            %61 = llvm.getelementptr %56[%c0_i32_60, %c2_i32_61] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %62 = llvm.mlir.null : !llvm.ptr<i8>
            %63 = "polygeist.pointer2memref"(%62) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %63, %61 : !llvm.ptr<memref<?xi32>>
            %c0_i32_62 = arith.constant 0 : i32
            %c3_i32_63 = arith.constant 3 : i32
            %64 = llvm.getelementptr %56[%c0_i32_62, %c3_i32_63] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c68_i8 = arith.constant 68 : i8
            %c68_i32 = arith.constant 68 : i32
            llvm.store %c68_i32, %64 : !llvm.ptr<i32>
            %c0_i32_64 = arith.constant 0 : i32
            %c5_i32 = arith.constant 5 : i32
            %65 = llvm.getelementptr %0[%c0_i32_64, %c5_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_65 = arith.constant 0 : i32
            %c0_i32_66 = arith.constant 0 : i32
            %66 = llvm.getelementptr %65[%c0_i32_65, %c0_i32_66] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %67 = llvm.mlir.addressof @str10 : !llvm.ptr<array<8 x i8>>
            %c0_i32_67 = arith.constant 0 : i32
            %c0_i32_68 = arith.constant 0 : i32
            %68 = llvm.getelementptr %67[%c0_i32_67, %c0_i32_68] : (!llvm.ptr<array<8 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %68, %66 : !llvm.ptr<ptr<i8>>
            %c0_i32_69 = arith.constant 0 : i32
            %c1_i32_70 = arith.constant 1 : i32
            %69 = llvm.getelementptr %65[%c0_i32_69, %c1_i32_70] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_71 = arith.constant 0 : i32
            llvm.store %c0_i32_71, %69 : !llvm.ptr<i32>
            %c0_i32_72 = arith.constant 0 : i32
            %c2_i32_73 = arith.constant 2 : i32
            %70 = llvm.getelementptr %65[%c0_i32_72, %c2_i32_73] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %71 = llvm.mlir.null : !llvm.ptr<i8>
            %72 = "polygeist.pointer2memref"(%71) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %72, %70 : !llvm.ptr<memref<?xi32>>
            %c0_i32_74 = arith.constant 0 : i32
            %c3_i32_75 = arith.constant 3 : i32
            %73 = llvm.getelementptr %65[%c0_i32_74, %c3_i32_75] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c102_i8 = arith.constant 102 : i8
            %c102_i32 = arith.constant 102 : i32
            llvm.store %c102_i32, %73 : !llvm.ptr<i32>
            %c0_i32_76 = arith.constant 0 : i32
            %c6_i32 = arith.constant 6 : i32
            %74 = llvm.getelementptr %0[%c0_i32_76, %c6_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_77 = arith.constant 0 : i32
            %c0_i32_78 = arith.constant 0 : i32
            %75 = llvm.getelementptr %74[%c0_i32_77, %c0_i32_78] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %76 = llvm.mlir.addressof @str11 : !llvm.ptr<array<8 x i8>>
            %c0_i32_79 = arith.constant 0 : i32
            %c0_i32_80 = arith.constant 0 : i32
            %77 = llvm.getelementptr %76[%c0_i32_79, %c0_i32_80] : (!llvm.ptr<array<8 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %77, %75 : !llvm.ptr<ptr<i8>>
            %c0_i32_81 = arith.constant 0 : i32
            %c1_i32_82 = arith.constant 1 : i32
            %78 = llvm.getelementptr %74[%c0_i32_81, %c1_i32_82] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_83 = arith.constant 0 : i32
            llvm.store %c0_i32_83, %78 : !llvm.ptr<i32>
            %c0_i32_84 = arith.constant 0 : i32
            %c2_i32_85 = arith.constant 2 : i32
            %79 = llvm.getelementptr %74[%c0_i32_84, %c2_i32_85] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %80 = llvm.mlir.null : !llvm.ptr<i8>
            %81 = "polygeist.pointer2memref"(%80) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %81, %79 : !llvm.ptr<memref<?xi32>>
            %c0_i32_86 = arith.constant 0 : i32
            %c3_i32_87 = arith.constant 3 : i32
            %82 = llvm.getelementptr %74[%c0_i32_86, %c3_i32_87] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c114_i8 = arith.constant 114 : i8
            %c114_i32 = arith.constant 114 : i32
            llvm.store %c114_i32, %82 : !llvm.ptr<i32>
            %c0_i32_88 = arith.constant 0 : i32
            %c7_i32 = arith.constant 7 : i32
            %83 = llvm.getelementptr %0[%c0_i32_88, %c7_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_89 = arith.constant 0 : i32
            %c0_i32_90 = arith.constant 0 : i32
            %84 = llvm.getelementptr %83[%c0_i32_89, %c0_i32_90] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %85 = llvm.mlir.addressof @str12 : !llvm.ptr<array<3 x i8>>
            %c0_i32_91 = arith.constant 0 : i32
            %c0_i32_92 = arith.constant 0 : i32
            %86 = llvm.getelementptr %85[%c0_i32_91, %c0_i32_92] : (!llvm.ptr<array<3 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %86, %84 : !llvm.ptr<ptr<i8>>
            %c0_i32_93 = arith.constant 0 : i32
            %c1_i32_94 = arith.constant 1 : i32
            %87 = llvm.getelementptr %83[%c0_i32_93, %c1_i32_94] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_95 = arith.constant 0 : i32
            llvm.store %c0_i32_95, %87 : !llvm.ptr<i32>
            %c0_i32_96 = arith.constant 0 : i32
            %c2_i32_97 = arith.constant 2 : i32
            %88 = llvm.getelementptr %83[%c0_i32_96, %c2_i32_97] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %89 = llvm.mlir.null : !llvm.ptr<i8>
            %90 = "polygeist.pointer2memref"(%89) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %90, %88 : !llvm.ptr<memref<?xi32>>
            %c0_i32_98 = arith.constant 0 : i32
            %c3_i32_99 = arith.constant 3 : i32
            %91 = llvm.getelementptr %83[%c0_i32_98, %c3_i32_99] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c57_i8 = arith.constant 57 : i8
            %c57_i32 = arith.constant 57 : i32
            llvm.store %c57_i32, %91 : !llvm.ptr<i32>
            %c0_i32_100 = arith.constant 0 : i32
            %c8_i32 = arith.constant 8 : i32
            %92 = llvm.getelementptr %0[%c0_i32_100, %c8_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_101 = arith.constant 0 : i32
            %c0_i32_102 = arith.constant 0 : i32
            %93 = llvm.getelementptr %92[%c0_i32_101, %c0_i32_102] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %94 = llvm.mlir.addressof @str13 : !llvm.ptr<array<3 x i8>>
            %c0_i32_103 = arith.constant 0 : i32
            %c0_i32_104 = arith.constant 0 : i32
            %95 = llvm.getelementptr %94[%c0_i32_103, %c0_i32_104] : (!llvm.ptr<array<3 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %95, %93 : !llvm.ptr<ptr<i8>>
            %c0_i32_105 = arith.constant 0 : i32
            %c1_i32_106 = arith.constant 1 : i32
            %96 = llvm.getelementptr %92[%c0_i32_105, %c1_i32_106] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_107 = arith.constant 0 : i32
            llvm.store %c0_i32_107, %96 : !llvm.ptr<i32>
            %c0_i32_108 = arith.constant 0 : i32
            %c2_i32_109 = arith.constant 2 : i32
            %97 = llvm.getelementptr %92[%c0_i32_108, %c2_i32_109] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %98 = llvm.mlir.null : !llvm.ptr<i8>
            %99 = "polygeist.pointer2memref"(%98) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %99, %97 : !llvm.ptr<memref<?xi32>>
            %c0_i32_110 = arith.constant 0 : i32
            %c3_i32_111 = arith.constant 3 : i32
            %100 = llvm.getelementptr %92[%c0_i32_110, %c3_i32_111] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c53_i8 = arith.constant 53 : i8
            %c53_i32 = arith.constant 53 : i32
            llvm.store %c53_i32, %100 : !llvm.ptr<i32>
            %c0_i32_112 = arith.constant 0 : i32
            %c9_i32 = arith.constant 9 : i32
            %101 = llvm.getelementptr %0[%c0_i32_112, %c9_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_113 = arith.constant 0 : i32
            %c0_i32_114 = arith.constant 0 : i32
            %102 = llvm.getelementptr %101[%c0_i32_113, %c0_i32_114] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %103 = llvm.mlir.addressof @str14 : !llvm.ptr<array<13 x i8>>
            %c0_i32_115 = arith.constant 0 : i32
            %c0_i32_116 = arith.constant 0 : i32
            %104 = llvm.getelementptr %103[%c0_i32_115, %c0_i32_116] : (!llvm.ptr<array<13 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %104, %102 : !llvm.ptr<ptr<i8>>
            %c0_i32_117 = arith.constant 0 : i32
            %c1_i32_118 = arith.constant 1 : i32
            %105 = llvm.getelementptr %101[%c0_i32_117, %c1_i32_118] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_119 = arith.constant 0 : i32
            llvm.store %c0_i32_119, %105 : !llvm.ptr<i32>
            %c0_i32_120 = arith.constant 0 : i32
            %c2_i32_121 = arith.constant 2 : i32
            %106 = llvm.getelementptr %101[%c0_i32_120, %c2_i32_121] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %107 = llvm.mlir.null : !llvm.ptr<i8>
            %108 = "polygeist.pointer2memref"(%107) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %108, %106 : !llvm.ptr<memref<?xi32>>
            %c0_i32_122 = arith.constant 0 : i32
            %c3_i32_123 = arith.constant 3 : i32
            %109 = llvm.getelementptr %101[%c0_i32_122, %c3_i32_123] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c119_i8 = arith.constant 119 : i8
            %c119_i32 = arith.constant 119 : i32
            llvm.store %c119_i32, %109 : !llvm.ptr<i32>
            %c0_i32_124 = arith.constant 0 : i32
            %c10_i32 = arith.constant 10 : i32
            %110 = llvm.getelementptr %0[%c0_i32_124, %c10_i32] : (!llvm.ptr<!llvm.array<11 x !llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>>, i32, i32) -> !llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>
            %c0_i32_125 = arith.constant 0 : i32
            %c0_i32_126 = arith.constant 0 : i32
            %111 = llvm.getelementptr %110[%c0_i32_125, %c0_i32_126] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<ptr<i8>>
            %112 = llvm.mlir.addressof @str15 : !llvm.ptr<array<5 x i8>>
            %c0_i32_127 = arith.constant 0 : i32
            %c0_i32_128 = arith.constant 0 : i32
            %113 = llvm.getelementptr %112[%c0_i32_127, %c0_i32_128] : (!llvm.ptr<array<5 x i8>>, i32, i32) -> !llvm.ptr<i8>
            llvm.store %113, %111 : !llvm.ptr<ptr<i8>>
            %c0_i32_129 = arith.constant 0 : i32
            %c1_i32_130 = arith.constant 1 : i32
            %114 = llvm.getelementptr %110[%c0_i32_129, %c1_i32_130] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c0_i32_131 = arith.constant 0 : i32
            llvm.store %c0_i32_131, %114 : !llvm.ptr<i32>
            %c0_i32_132 = arith.constant 0 : i32
            %c2_i32_133 = arith.constant 2 : i32
            %115 = llvm.getelementptr %110[%c0_i32_132, %c2_i32_133] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<memref<?xi32>>
            %116 = llvm.mlir.null : !llvm.ptr<i8>
            %117 = "polygeist.pointer2memref"(%116) : (!llvm.ptr<i8>) -> memref<?xi32>
            llvm.store %117, %115 : !llvm.ptr<memref<?xi32>>
            %c0_i32_134 = arith.constant 0 : i32
            %c3_i32_135 = arith.constant 3 : i32
            %118 = llvm.getelementptr %110[%c0_i32_134, %c3_i32_135] : (!llvm.ptr<!llvm.struct<(ptr<i8>, i32, memref<?xi32>, i32)>>, i32, i32) -> !llvm.ptr<i32>
            %c104_i8 = arith.constant 104 : i8
            %c104_i32 = arith.constant 104 : i32
            llvm.store %c104_i32, %118 : !llvm.ptr<i32>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %17 = memref.load %10[] : memref<i1>
    scf.if %17 {
      scf.execute_region {
        %19 = memref.load %10[] : memref<i1>
        scf.if %19 {
          scf.execute_region {
            %c0_i32 = arith.constant 0 : i32
            memref.store %c0_i32, %12[] : memref<i32>
            %false = arith.constant false
            memref.store %false, %10[] : memref<i1>
            memref.store %false, %11[] : memref<i1>
            scf.yield
          }
        }
        scf.yield
      }
    }
    %18 = memref.load %12[] : memref<i32>
    return %18 : i32
  }
}
</immediate: mlir>
warning: argument unused during compilation: '--cuda-gpu-arch=sm_60'
warning: overriding the module target triple with x86_64-unknown-linux-gnu [-Woverride-module]
1 warning generated.
